{"ast":null,"code":"'use strict'; // util\n\nfunction fillStr(s, num) {\n  return Array(num + 1).join(s);\n}\n\nfunction isNum(x) {\n  return typeof x === 'number';\n}\n\nfunction isStr(x) {\n  return typeof x === 'string';\n}\n\nfunction isDef(x) {\n  return typeof x !== 'undefined';\n}\n\nfunction midiToFreq(midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440);\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\n\nexport function regex() {\n  return REGEX;\n}\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11];\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\n\nexport function parse(str, isTonic, tuning) {\n  if (typeof str !== 'string') return null;\n  var m = REGEX.exec(str);\n  if (!m || !isTonic && m[4]) return null;\n  var p = {\n    letter: m[1].toUpperCase(),\n    acc: m[2].replace(/x/g, '##')\n  };\n  p.pc = p.letter + p.acc;\n  p.step = (p.letter.charCodeAt(0) + 3) % 7;\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length;\n  var pos = SEMITONES[p.step] + p.alt;\n  p.chroma = pos < 0 ? 12 + pos : pos % 12;\n\n  if (m[3]) {\n    // has octave\n    p.oct = +m[3];\n    p.midi = pos + 12 * (p.oct + 1);\n    p.freq = midiToFreq(p.midi, tuning);\n  }\n\n  if (isTonic) p.tonicOf = m[4];\n  return p;\n}\nvar LETTERS = 'CDEFGAB';\n\nfunction accStr(n) {\n  return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n);\n}\n\nfunction octStr(n) {\n  return !isNum(n) ? '' : '' + n;\n}\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\n\n\nexport function build(s, a, o) {\n  if (s === null || typeof s === 'undefined') return null;\n  if (s.step) return build(s.step, s.alt, s.oct);\n  if (s < 0 || s > 6) return null;\n  return LETTERS.charAt(s) + accStr(a) + octStr(o);\n}\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\n\nexport function midi(note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note;\n  var p = parse(note);\n  return p && isDef(p.midi) ? p.midi : null;\n}\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\n\nexport function freq(note, tuning) {\n  var m = midi(note);\n  return m === null ? null : midiToFreq(m, tuning);\n}\nexport function letter(src) {\n  return (parse(src) || {}).letter;\n}\nexport function acc(src) {\n  return (parse(src) || {}).acc;\n}\nexport function pc(src) {\n  return (parse(src) || {}).pc;\n}\nexport function step(src) {\n  return (parse(src) || {}).step;\n}\nexport function alt(src) {\n  return (parse(src) || {}).alt;\n}\nexport function chroma(src) {\n  return (parse(src) || {}).chroma;\n}\nexport function oct(src) {\n  return (parse(src) || {}).oct;\n}","map":{"version":3,"sources":["/Users/sylviayu/node_modules/note-parser/index.js"],"names":["fillStr","s","num","Array","join","isNum","x","isStr","isDef","midiToFreq","midi","tuning","Math","pow","REGEX","regex","SEMITONES","parse","str","isTonic","m","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","pos","chroma","oct","freq","tonicOf","LETTERS","accStr","n","octStr","build","a","o","charAt","note","src"],"mappings":"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","sourcesContent":["'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nexport function regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nexport function parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || (!isTonic && m[4])) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nexport function build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nexport function midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nexport function freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nexport function letter (src) { return (parse(src) || {}).letter }\nexport function acc (src) { return (parse(src) || {}).acc }\nexport function pc (src) { return (parse(src) || {}).pc }\nexport function step (src) { return (parse(src) || {}).step }\nexport function alt (src) { return (parse(src) || {}).alt }\nexport function chroma (src) { return (parse(src) || {}).chroma }\nexport function oct (src) { return (parse(src) || {}).oct }\n"]},"metadata":{},"sourceType":"module"}