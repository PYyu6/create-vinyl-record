{"ast":null,"code":"module.exports = ADSR;\n\nfunction ADSR(audioContext) {\n  var node = audioContext.createGain();\n  var voltage = node._voltage = getVoltage(audioContext);\n  var value = scale(voltage);\n  var startValue = scale(voltage);\n  var endValue = scale(voltage);\n  node._startAmount = scale(startValue);\n  node._endAmount = scale(endValue);\n  node._multiplier = scale(value);\n\n  node._multiplier.connect(node);\n\n  node._startAmount.connect(node);\n\n  node._endAmount.connect(node);\n\n  node.value = value.gain;\n  node.startValue = startValue.gain;\n  node.endValue = endValue.gain;\n  node.startValue.value = 0;\n  node.endValue.value = 0;\n  Object.defineProperties(node, props);\n  return node;\n}\n\nvar props = {\n  attack: {\n    value: 0,\n    writable: true\n  },\n  decay: {\n    value: 0,\n    writable: true\n  },\n  sustain: {\n    value: 1,\n    writable: true\n  },\n  release: {\n    value: 0,\n    writable: true\n  },\n  getReleaseDuration: {\n    value: function value() {\n      return this.release;\n    }\n  },\n  start: {\n    value: function value(at) {\n      var target = this._multiplier.gain;\n      var startAmount = this._startAmount.gain;\n      var endAmount = this._endAmount.gain;\n\n      this._voltage.start(at);\n\n      this._decayFrom = this._decayFrom = at + this.attack;\n      this._startedAt = at;\n      var sustain = this.sustain;\n      target.cancelScheduledValues(at);\n      startAmount.cancelScheduledValues(at);\n      endAmount.cancelScheduledValues(at);\n      endAmount.setValueAtTime(0, at);\n\n      if (this.attack) {\n        target.setValueAtTime(0, at);\n        target.linearRampToValueAtTime(1, at + this.attack);\n        startAmount.setValueAtTime(1, at);\n        startAmount.linearRampToValueAtTime(0, at + this.attack);\n      } else {\n        target.setValueAtTime(1, at);\n        startAmount.setValueAtTime(0, at);\n      }\n\n      if (this.decay) {\n        target.setTargetAtTime(sustain, this._decayFrom, getTimeConstant(this.decay));\n      }\n    }\n  },\n  stop: {\n    value: function value(at, isTarget) {\n      if (isTarget) {\n        at = at - this.release;\n      }\n\n      var endTime = at + this.release;\n\n      if (this.release) {\n        var target = this._multiplier.gain;\n        var startAmount = this._startAmount.gain;\n        var endAmount = this._endAmount.gain;\n        target.cancelScheduledValues(at);\n        startAmount.cancelScheduledValues(at);\n        endAmount.cancelScheduledValues(at);\n        var expFalloff = getTimeConstant(this.release); // truncate attack (required as linearRamp is removed by cancelScheduledValues)\n\n        if (this.attack && at < this._decayFrom) {\n          var valueAtTime = getValue(0, 1, this._startedAt, this._decayFrom, at);\n          target.linearRampToValueAtTime(valueAtTime, at);\n          startAmount.linearRampToValueAtTime(1 - valueAtTime, at);\n          startAmount.setTargetAtTime(0, at, expFalloff);\n        }\n\n        endAmount.setTargetAtTime(1, at, expFalloff);\n        target.setTargetAtTime(0, at, expFalloff);\n      }\n\n      this._voltage.stop(endTime);\n\n      return endTime;\n    }\n  },\n  onended: {\n    get: function get() {\n      return this._voltage.onended;\n    },\n    set: function set(value) {\n      this._voltage.onended = value;\n    }\n  }\n};\nvar flat = new Float32Array([1, 1]);\n\nfunction getVoltage(context) {\n  var voltage = context.createBufferSource();\n  var buffer = context.createBuffer(1, 2, context.sampleRate);\n  buffer.getChannelData(0).set(flat);\n  voltage.buffer = buffer;\n  voltage.loop = true;\n  return voltage;\n}\n\nfunction scale(node) {\n  var gain = node.context.createGain();\n  node.connect(gain);\n  return gain;\n}\n\nfunction getTimeConstant(time) {\n  return Math.log(time + 1) / Math.log(100);\n}\n\nfunction getValue(start, end, fromTime, toTime, at) {\n  var difference = end - start;\n  var time = toTime - fromTime;\n  var truncateTime = at - fromTime;\n  var phase = truncateTime / time;\n  var value = start + phase * difference;\n\n  if (value <= start) {\n    value = start;\n  }\n\n  if (value >= end) {\n    value = end;\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/sylviayu/node_modules/adsr/index.js"],"names":["module","exports","ADSR","audioContext","node","createGain","voltage","_voltage","getVoltage","value","scale","startValue","endValue","_startAmount","_endAmount","_multiplier","connect","gain","Object","defineProperties","props","attack","writable","decay","sustain","release","getReleaseDuration","start","at","target","startAmount","endAmount","_decayFrom","_startedAt","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","setTargetAtTime","getTimeConstant","stop","isTarget","endTime","expFalloff","valueAtTime","getValue","onended","get","set","flat","Float32Array","context","createBufferSource","buffer","createBuffer","sampleRate","getChannelData","loop","time","Math","log","end","fromTime","toTime","difference","truncateTime","phase"],"mappings":"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","sourcesContent":["module.exports = ADSR\n\nfunction ADSR(audioContext){\n  var node = audioContext.createGain()\n\n  var voltage = node._voltage = getVoltage(audioContext)\n  var value = scale(voltage)\n  var startValue = scale(voltage)\n  var endValue = scale(voltage)\n\n  node._startAmount = scale(startValue)\n  node._endAmount = scale(endValue)\n\n  node._multiplier = scale(value)\n  node._multiplier.connect(node)\n  node._startAmount.connect(node)\n  node._endAmount.connect(node)\n\n  node.value = value.gain\n  node.startValue = startValue.gain\n  node.endValue = endValue.gain\n\n  node.startValue.value = 0\n  node.endValue.value = 0\n\n  Object.defineProperties(node, props)\n  return node\n}\n\nvar props = {\n\n  attack: { value: 0, writable: true },\n  decay: { value: 0, writable: true },\n  sustain: { value: 1, writable: true },\n  release: {value: 0, writable: true },\n\n  getReleaseDuration: {\n    value: function(){\n      return this.release\n    }\n  },\n\n  start: {\n    value: function(at){\n      var target = this._multiplier.gain\n      var startAmount = this._startAmount.gain\n      var endAmount = this._endAmount.gain\n\n      this._voltage.start(at)\n      this._decayFrom = this._decayFrom = at+this.attack\n      this._startedAt = at\n\n      var sustain = this.sustain\n\n      target.cancelScheduledValues(at)\n      startAmount.cancelScheduledValues(at)\n      endAmount.cancelScheduledValues(at)\n\n      endAmount.setValueAtTime(0, at)\n\n      if (this.attack){\n        target.setValueAtTime(0, at)\n        target.linearRampToValueAtTime(1, at + this.attack)\n\n        startAmount.setValueAtTime(1, at)\n        startAmount.linearRampToValueAtTime(0, at + this.attack)\n      } else {\n        target.setValueAtTime(1, at)\n        startAmount.setValueAtTime(0, at)\n      }\n\n      if (this.decay){\n        target.setTargetAtTime(sustain, this._decayFrom, getTimeConstant(this.decay))\n      }\n    }\n  },\n\n  stop: {\n    value: function(at, isTarget){\n      if (isTarget){\n        at = at - this.release\n      }\n\n      var endTime = at + this.release\n      if (this.release){\n\n        var target = this._multiplier.gain\n        var startAmount = this._startAmount.gain\n        var endAmount = this._endAmount.gain\n\n        target.cancelScheduledValues(at)\n        startAmount.cancelScheduledValues(at)\n        endAmount.cancelScheduledValues(at)\n\n        var expFalloff = getTimeConstant(this.release)\n\n        // truncate attack (required as linearRamp is removed by cancelScheduledValues)\n        if (this.attack && at < this._decayFrom){\n          var valueAtTime = getValue(0, 1, this._startedAt, this._decayFrom, at)\n          target.linearRampToValueAtTime(valueAtTime, at)\n          startAmount.linearRampToValueAtTime(1-valueAtTime, at)\n          startAmount.setTargetAtTime(0, at, expFalloff)\n        }\n\n        endAmount.setTargetAtTime(1, at, expFalloff)\n        target.setTargetAtTime(0, at, expFalloff)\n      }\n\n      this._voltage.stop(endTime)\n      return endTime\n    }\n  },\n\n  onended: {\n    get: function(){\n      return this._voltage.onended\n    },\n    set: function(value){\n      this._voltage.onended = value\n    }\n  }\n\n}\n\nvar flat = new Float32Array([1,1])\nfunction getVoltage(context){\n  var voltage = context.createBufferSource()\n  var buffer = context.createBuffer(1, 2, context.sampleRate)\n  buffer.getChannelData(0).set(flat)\n  voltage.buffer = buffer\n  voltage.loop = true\n  return voltage\n}\n\nfunction scale(node){\n  var gain = node.context.createGain()\n  node.connect(gain)\n  return gain\n}\n\nfunction getTimeConstant(time){\n  return Math.log(time+1)/Math.log(100)\n}\n\nfunction getValue(start, end, fromTime, toTime, at){\n  var difference = end - start\n  var time = toTime - fromTime\n  var truncateTime = at - fromTime\n  var phase = truncateTime / time\n  var value = start + phase * difference\n\n  if (value <= start) {\n      value = start\n  }\n  if (value >= end) {\n      value = end\n  }\n\n  return value\n}\n"]},"metadata":{},"sourceType":"script"}