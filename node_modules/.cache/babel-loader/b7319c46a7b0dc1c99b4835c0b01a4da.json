{"ast":null,"code":"/* global AudioBuffer */\n'use strict';\n\nvar ADSR = require('adsr');\n\nvar EMPTY = {};\nvar DEFAULTS = {\n  gain: 1,\n  attack: 0.01,\n  decay: 0.1,\n  sustain: 0.9,\n  release: 0.3,\n  loop: false,\n  cents: 0,\n  loopStart: 0,\n  loopEnd: 0\n};\n/**\n * Create a sample player.\n *\n * @param {AudioContext} ac - the audio context\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\n * @param {Onject} options - (Optional) an options object\n * @return {player} the player\n * @example\n * var SamplePlayer = require('sample-player')\n * var ac = new AudioContext()\n * var snare = SamplePlayer(ac, <AudioBuffer>)\n * snare.play()\n */\n\nfunction SamplePlayer(ac, source, options) {\n  var connected = false;\n  var nextId = 0;\n  var tracked = {};\n  var out = ac.createGain();\n  out.gain.value = 1;\n  var opts = Object.assign({}, DEFAULTS, options);\n  /**\n   * @namespace\n   */\n\n  var player = {\n    context: ac,\n    out: out,\n    opts: opts\n  };\n  if (source instanceof AudioBuffer) player.buffer = source;else player.buffers = source;\n  /**\n   * Start a sample buffer.\n   *\n   * The returned object has a function `stop(when)` to stop the sound.\n   *\n   * @param {String} name - the name of the buffer. If the source of the\n   * SamplePlayer is one sample buffer, this parameter is not required\n   * @param {Float} when - (Optional) when to start (current time if by default)\n   * @param {Object} options - additional sample playing options\n   * @return {AudioNode} an audio node with a `stop` function\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   * sample.start()\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\n   * @example\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\n   * drums.start('snare')\n   * drums.start('snare', 0, { gain: 0.3 })\n   */\n\n  player.start = function (name, when, options) {\n    // if only one buffer, reorder arguments\n    if (player.buffer && name !== null) return player.start(null, name, when);\n    var buffer = name ? player.buffers[name] : player.buffer;\n\n    if (!buffer) {\n      console.warn('Buffer ' + name + ' not found.');\n      return;\n    } else if (!connected) {\n      console.warn('SamplePlayer not connected to any node.');\n      return;\n    }\n\n    var opts = options || EMPTY;\n    when = Math.max(ac.currentTime, when || 0);\n    player.emit('start', when, name, opts);\n    var node = createNode(name, buffer, opts);\n    node.id = track(name, node);\n    node.env.start(when);\n    node.source.start(when);\n    player.emit('started', when, node.id, node);\n    if (opts.duration) node.stop(when + opts.duration);\n    return node;\n  }; // NOTE: start will be override so we can't copy the function reference\n  // this is obviously not a good design, so this code will be gone soon.\n\n  /**\n   * An alias for `player.start`\n   * @see player.start\n   * @since 0.3.0\n   */\n\n\n  player.play = function (name, when, options) {\n    return player.start(name, when, options);\n  };\n  /**\n   * Stop some or all samples\n   *\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\n   * if not specified)\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\n   * @return {Array} an array of ids of the stoped samples\n   *\n   * @example\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\n   * longSound.start(ac.currentTime)\n   * longSound.start(ac.currentTime + 1)\n   * longSound.start(ac.currentTime + 2)\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\n   */\n\n\n  player.stop = function (when, ids) {\n    var node;\n    ids = ids || Object.keys(tracked);\n    return ids.map(function (id) {\n      node = tracked[id];\n      if (!node) return null;\n      node.stop(when);\n      return node.id;\n    });\n  };\n  /**\n   * Connect the player to a destination node\n   *\n   * @param {AudioNode} destination - the destination node\n   * @return {AudioPlayer} the player\n   * @chainable\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   */\n\n\n  player.connect = function (dest) {\n    connected = true;\n    out.connect(dest);\n    return player;\n  };\n\n  player.emit = function (event, when, obj, opts) {\n    if (player.onevent) player.onevent(event, when, obj, opts);\n    var fn = player['on' + event];\n    if (fn) fn(when, obj, opts);\n  };\n\n  return player; // =============== PRIVATE FUNCTIONS ============== //\n\n  function track(name, node) {\n    node.id = nextId++;\n    tracked[node.id] = node;\n\n    node.source.onended = function () {\n      var now = ac.currentTime;\n      node.source.disconnect();\n      node.env.disconnect();\n      node.disconnect();\n      player.emit('ended', now, node.id, node);\n    };\n\n    return node.id;\n  }\n\n  function createNode(name, buffer, options) {\n    var node = ac.createGain();\n    node.gain.value = 0; // the envelope will control the gain\n\n    node.connect(out);\n    node.env = envelope(ac, options, opts);\n    node.env.connect(node.gain);\n    node.source = ac.createBufferSource();\n    node.source.buffer = buffer;\n    node.source.connect(node);\n    node.source.loop = options.loop || opts.loop;\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents);\n    node.source.loopStart = options.loopStart || opts.loopStart;\n    node.source.loopEnd = options.loopEnd || opts.loopEnd;\n\n    node.stop = function (when) {\n      var time = when || ac.currentTime;\n      player.emit('stop', time, name);\n      var stopAt = node.env.stop(time);\n      node.source.stop(stopAt);\n    };\n\n    return node;\n  }\n}\n\nfunction isNum(x) {\n  return typeof x === 'number';\n}\n\nvar PARAMS = ['attack', 'decay', 'sustain', 'release'];\n\nfunction envelope(ac, options, opts) {\n  var env = ADSR(ac);\n  var adsr = options.adsr || opts.adsr;\n  PARAMS.forEach(function (name, i) {\n    if (adsr) env[name] = adsr[i];else env[name] = options[name] || opts[name];\n  });\n  env.value.value = isNum(options.gain) ? options.gain : isNum(opts.gain) ? opts.gain : 1;\n  return env;\n}\n/*\n * Get playback rate for a given pitch change (in cents)\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\n * f2 = f1 * 2^( C / 1200 )\n */\n\n\nfunction centsToRate(cents) {\n  return cents ? Math.pow(2, cents / 1200) : 1;\n}\n\nmodule.exports = SamplePlayer;","map":{"version":3,"sources":["/Users/sylviayu/node_modules/sample-player/lib/player.js"],"names":["ADSR","require","EMPTY","DEFAULTS","gain","attack","decay","sustain","release","loop","cents","loopStart","loopEnd","SamplePlayer","ac","source","options","connected","nextId","tracked","out","createGain","value","opts","Object","assign","player","context","AudioBuffer","buffer","buffers","start","name","when","console","warn","Math","max","currentTime","emit","node","createNode","id","track","env","duration","stop","play","ids","keys","map","connect","dest","event","obj","onevent","fn","onended","now","disconnect","envelope","createBufferSource","playbackRate","centsToRate","time","stopAt","isNum","x","PARAMS","adsr","forEach","i","pow","module","exports"],"mappings":"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","sourcesContent":["/* global AudioBuffer */\n'use strict'\n\nvar ADSR = require('adsr')\n\nvar EMPTY = {}\nvar DEFAULTS = {\n  gain: 1,\n  attack: 0.01,\n  decay: 0.1,\n  sustain: 0.9,\n  release: 0.3,\n  loop: false,\n  cents: 0,\n  loopStart: 0,\n  loopEnd: 0\n}\n\n/**\n * Create a sample player.\n *\n * @param {AudioContext} ac - the audio context\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\n * @param {Onject} options - (Optional) an options object\n * @return {player} the player\n * @example\n * var SamplePlayer = require('sample-player')\n * var ac = new AudioContext()\n * var snare = SamplePlayer(ac, <AudioBuffer>)\n * snare.play()\n */\nfunction SamplePlayer (ac, source, options) {\n  var connected = false\n  var nextId = 0\n  var tracked = {}\n  var out = ac.createGain()\n  out.gain.value = 1\n\n  var opts = Object.assign({}, DEFAULTS, options)\n\n  /**\n   * @namespace\n   */\n  var player = { context: ac, out: out, opts: opts }\n  if (source instanceof AudioBuffer) player.buffer = source\n  else player.buffers = source\n\n  /**\n   * Start a sample buffer.\n   *\n   * The returned object has a function `stop(when)` to stop the sound.\n   *\n   * @param {String} name - the name of the buffer. If the source of the\n   * SamplePlayer is one sample buffer, this parameter is not required\n   * @param {Float} when - (Optional) when to start (current time if by default)\n   * @param {Object} options - additional sample playing options\n   * @return {AudioNode} an audio node with a `stop` function\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   * sample.start()\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\n   * @example\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\n   * drums.start('snare')\n   * drums.start('snare', 0, { gain: 0.3 })\n   */\n  player.start = function (name, when, options) {\n    // if only one buffer, reorder arguments\n    if (player.buffer && name !== null) return player.start(null, name, when)\n\n    var buffer = name ? player.buffers[name] : player.buffer\n    if (!buffer) {\n      console.warn('Buffer ' + name + ' not found.')\n      return\n    } else if (!connected) {\n      console.warn('SamplePlayer not connected to any node.')\n      return\n    }\n\n    var opts = options || EMPTY\n    when = Math.max(ac.currentTime, when || 0)\n    player.emit('start', when, name, opts)\n    var node = createNode(name, buffer, opts)\n    node.id = track(name, node)\n    node.env.start(when)\n    node.source.start(when)\n    player.emit('started', when, node.id, node)\n    if (opts.duration) node.stop(when + opts.duration)\n    return node\n  }\n\n  // NOTE: start will be override so we can't copy the function reference\n  // this is obviously not a good design, so this code will be gone soon.\n  /**\n   * An alias for `player.start`\n   * @see player.start\n   * @since 0.3.0\n   */\n  player.play = function (name, when, options) {\n    return player.start(name, when, options)\n  }\n\n  /**\n   * Stop some or all samples\n   *\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\n   * if not specified)\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\n   * @return {Array} an array of ids of the stoped samples\n   *\n   * @example\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\n   * longSound.start(ac.currentTime)\n   * longSound.start(ac.currentTime + 1)\n   * longSound.start(ac.currentTime + 2)\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\n   */\n  player.stop = function (when, ids) {\n    var node\n    ids = ids || Object.keys(tracked)\n    return ids.map(function (id) {\n      node = tracked[id]\n      if (!node) return null\n      node.stop(when)\n      return node.id\n    })\n  }\n  /**\n   * Connect the player to a destination node\n   *\n   * @param {AudioNode} destination - the destination node\n   * @return {AudioPlayer} the player\n   * @chainable\n   * @example\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\n   */\n  player.connect = function (dest) {\n    connected = true\n    out.connect(dest)\n    return player\n  }\n\n  player.emit = function (event, when, obj, opts) {\n    if (player.onevent) player.onevent(event, when, obj, opts)\n    var fn = player['on' + event]\n    if (fn) fn(when, obj, opts)\n  }\n\n  return player\n\n  // =============== PRIVATE FUNCTIONS ============== //\n\n  function track (name, node) {\n    node.id = nextId++\n    tracked[node.id] = node\n    node.source.onended = function () {\n      var now = ac.currentTime\n      node.source.disconnect()\n      node.env.disconnect()\n      node.disconnect()\n      player.emit('ended', now, node.id, node)\n    }\n    return node.id\n  }\n\n  function createNode (name, buffer, options) {\n    var node = ac.createGain()\n    node.gain.value = 0 // the envelope will control the gain\n    node.connect(out)\n\n    node.env = envelope(ac, options, opts)\n    node.env.connect(node.gain)\n\n    node.source = ac.createBufferSource()\n    node.source.buffer = buffer\n    node.source.connect(node)\n    node.source.loop = options.loop || opts.loop\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents)\n    node.source.loopStart = options.loopStart || opts.loopStart\n    node.source.loopEnd = options.loopEnd || opts.loopEnd\n    node.stop = function (when) {\n      var time = when || ac.currentTime\n      player.emit('stop', time, name)\n      var stopAt = node.env.stop(time)\n      node.source.stop(stopAt)\n    }\n    return node\n  }\n}\n\nfunction isNum (x) { return typeof x === 'number' }\nvar PARAMS = ['attack', 'decay', 'sustain', 'release']\nfunction envelope (ac, options, opts) {\n  var env = ADSR(ac)\n  var adsr = options.adsr || opts.adsr\n  PARAMS.forEach(function (name, i) {\n    if (adsr) env[name] = adsr[i]\n    else env[name] = options[name] || opts[name]\n  })\n  env.value.value = isNum(options.gain) ? options.gain\n    : isNum(opts.gain) ? opts.gain : 1\n  return env\n}\n\n/*\n * Get playback rate for a given pitch change (in cents)\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\n * f2 = f1 * 2^( C / 1200 )\n */\nfunction centsToRate (cents) { return cents ? Math.pow(2, cents / 1200) : 1 }\n\nmodule.exports = SamplePlayer\n"]},"metadata":{},"sourceType":"script"}