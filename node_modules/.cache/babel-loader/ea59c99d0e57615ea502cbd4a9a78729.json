{"ast":null,"code":"'use strict';\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\n\nfunction regex() {\n  return REGEX;\n}\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11];\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true if the note is the tonic of something.\n * If true, en extra tonicOf property is returned. It's false by default.\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.\n * Can detect pitch class enhramonics.\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\n\nfunction parse(str, isTonic, tuning) {\n  if (typeof str !== 'string') return null;\n  var m = REGEX.exec(str);\n  if (!m || !isTonic && m[4]) return null;\n  var p = {\n    letter: m[1].toUpperCase(),\n    acc: m[2].replace(/x/g, '##')\n  };\n  p.pc = p.letter + p.acc;\n  p.step = (p.letter.charCodeAt(0) + 3) % 7;\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length;\n  p.chroma = SEMITONES[p.step] + p.alt;\n\n  if (m[3]) {\n    p.oct = +m[3];\n    p.midi = p.chroma + 12 * (p.oct + 1);\n    p.freq = midiToFreq(p.midi, tuning);\n  }\n\n  if (isTonic) p.tonicOf = m[4];\n  return p;\n}\n/**\n * Given a midi number, return its frequency\n * @param {Integer} midi - midi note number\n * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)\n * @return {Float} frequency in hertzs\n */\n\n\nfunction midiToFreq(midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440);\n}\n\nvar parser = {\n  parse: parse,\n  regex: regex,\n  midiToFreq: midiToFreq\n};\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq'];\nFNS.forEach(function (name) {\n  parser[name] = function (src) {\n    var p = parse(src);\n    return p && typeof p[name] !== 'undefined' ? p[name] : null;\n  };\n});\nmodule.exports = parser; // extra API docs\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String} note - the note name\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n */\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n */","map":{"version":3,"sources":["/Users/sylviayu/node_modules/sample-player/node_modules/note-parser/index.js"],"names":["REGEX","regex","SEMITONES","parse","str","isTonic","tuning","m","exec","p","letter","toUpperCase","acc","replace","pc","step","charCodeAt","alt","length","chroma","oct","midi","freq","midiToFreq","tonicOf","Math","pow","parser","FNS","forEach","name","src","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nfunction regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true if the note is the tonic of something.\n * If true, en extra tonicOf property is returned. It's false by default.\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.\n * Can detect pitch class enhramonics.\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nfunction parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || !isTonic && m[4]) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  p.chroma = SEMITONES[p.step] + p.alt\n  if (m[3]) {\n    p.oct = +m[3]\n    p.midi = p.chroma + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\n/**\n * Given a midi number, return its frequency\n * @param {Integer} midi - midi note number\n * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)\n * @return {Float} frequency in hertzs\n */\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar parser = { parse: parse, regex: regex, midiToFreq: midiToFreq }\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq']\nFNS.forEach(function (name) {\n  parser[name] = function (src) {\n    var p = parse(src)\n    return p && (typeof p[name] !== 'undefined') ? p[name] : null\n  }\n})\n\nmodule.exports = parser\n\n// extra API docs\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String} note - the note name\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n */\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n */\n"]},"metadata":{},"sourceType":"script"}